<application>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1696641794082" />
  </component>
  <component name="Translation.Settings">
    <option name="primaryLanguage" value="CHINESE" />
  </component>
  <component name="Translation.States">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="2754" />
    <option name="newTranslationDialogY" value="476" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Get Cone Side Tangent Points" />
      <item value="The first horizon point expressed as factors of" />
      <item value="Find Y by putting polar into line equation and solving. Denormalize by dividing by U and V lengths." />
      <item value="polar" />
      <item value="Find Y by putting polar into line equation and solving" />
      <item value="Major and minor axis of the ellipse" />
      <item value="Find the polar line of the camera position in the normalized UV coordinate system." />
      <item value="Project the camera position into a 2D coordinate system with the circle at (0, 0) and the ellipse major and minor axes as the coordinate system axes. This allows us to use the standard form of the ellipse equation, greatly simplifying the calculations." />
      <item value="Intersect Ellipse Line" />
      <item value="Calculates the horizon of a circle orthogonally projected to a plane as seen from the origin on the plane." />
      <item value="Calculate the lines making up the sides of the cone as seen from the camera. `l1` and `l2` form lines from the light position." />
      <item value="Calculate tile plane ranges for cone" />
      <item value="Calculate tile plane ranges for cone." />
      <item value="Calculate the lines making up the sides of the cone as seen from the camera. `l1` and `l2` form lines" />
      <item value="Find the X bounds of the near-plane cone intersection, i.e. where x' = 0" />
      <item value="Find the Y bounds of the near-plane cone intersection," />
      <item value="The cross product will be the 0-vector if the light-direction and camera-to-light-position vectors are parallel. In that case, {1, 0, 0} is orthogonal to the light direction and we use that instead." />
      <item value="Conic" />
      <item value="Handle base circle clipping by intersecting it with the near-plane if needed." />
      <item value="Project cone base into the XZ plane, find the horizon points, and re-construct view space position of found points." />
      <item value="See comment for YZ plane for details" />
      <item value="Project cone base (a circle) into the YZ plane, find the horizon points, and re-construct view space position of found points. When projecting a circle to a plane, it becomes an ellipse where the major axis is parallel to the line of intersection of the projection plane and the circle plane. We can get this by taking the cross product of the two plane normals, as the line of intersection will have to be a vector in both planes, and thus orthogonal to both normals. If the two plane normals are parallel, the cross product would return 0. In that case, the circle will project to a line segment, so we pick a vector in the plane pointing in the direction we're interested in finding horizon points in." />
      <item value="the point is on the sphere, it must be `sphereRadius` from the sphere center, forming the hypotenuse. The other side is between the sphere and circle centers, which we've already calculated to be `distanceToPlane`." />
      <item value="Pythagoras" />
      <item value="Finds the two points of intersection of a 3D circle and the near plane." />
      <item value="thus orthogonal to both normals." />
      <item value="Transform horizon points to view space and use if not clipped." />
      <item value="They are signs that clipping is needed, so we fallback on the already calculated values in that case." />
      <item value="negative square roots." />
      <item value="Any of these conditions will yield NaN due to negative square roots. They are signs that clipping is needed, so we fallback on the already calculated values in that case." />
      <item value="The shortest distance from the sphere center and the y-plane. The sign determines which side of the plane the center is on." />
      <item value="Direction from origin to the circle center." />
      <item value="The center of the intersection circle in the y-plane, which is the point on the plane closest to the sphere center. I.e. this is at `distanceToPlane` from the center." />
      <item value="Calculate the radius of the circle using Pythagoras. We know that any point on the circle is a point on the sphere. Thus we can construct a triangle with the sphere center, circle center, and a point on the circle. We then want to find its distance to the circle center, as that will be equal to the radius. As the point is on the sphere, it must be `sphereRadius` from the sphere center, forming the hypotenuse. The other side is between the sphere and circle centers, which we've already calculated to be" />
      <item value="Near-plane clipping - will get overwritten if no clipping is needed. `y` is given for the view plane (Z=1), scale it so that it is on the near plane instead." />
      <item value="Unsigned shortest distance from the sphere center to the plane." />
      <item value="Basis vectors in the y-plane for being able to parameterize the plane." />
      <item value="Calculate the radius of the circle using Pythagoras. We know that any point on the circle is a point on the sphere. Thus we can construct a triangle with the sphere center, circle center, and a point on the circle. We then want to find its distance to the circle center, as that will be equal to the radius. As the point is on the sphere, it must be `sphereRadius` from the sphere center, forming the hypotenuse. The other side is between the sphere and circle centers, which we've already calculated to be `distanceToPlane`." />
      <item value="Now that we have the circle, we can find the horizon points. Since we've parametrized the plane, we can just do this in 2D." />
      <item value="Calculate tile plane ranges for sphere" />
      <item value="cone Height Sq" />
      <item value="scale it so that it is on the near plane instead." />
      <item value="Note: The y-plane is the plane that is determined by `y` in that it contains the vector (1, 0, 0) and goes through the points (0, y, 1) and (0, 0, 0). This would become a straight line in screen-space, and so it represents the boundary between two rows of tiles." />
      <item value="horizon points" />
      <item value="Project light sphere onto YZ plane, find the horizon points, and re-construct view space position of found points" />
      <item value="Assumes a point on the sphere, i.e. at distance `range` from the light position. If spot light, we check the angle between the direction vector from the light position and the light direction vector. Note that division by range is to normalize the vector, as we know that the resulting vector will have length `range`." />
      <item value="Finds the two horizon points seen from (0, 0) of a sphere projected onto either XZ or YZ. Takes clipping into account." />
      <item value="and re-construct view space position of found points." />
      <item value="lies both on the sphere and the near plan" />
      <item value="Thus the hypotenuse is formed by (a) and (c) with length `range`, and the known side is formed" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="182" />
        <entry key="ENGLISH" value="183" />
        <entry key="GERMAN" value="1" />
      </map>
    </option>
  </component>
</application>