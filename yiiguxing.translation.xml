<application>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1697168980449" />
  </component>
  <component name="Translation.Settings">
    <option name="primaryLanguage" value="CHINESE" />
  </component>
  <component name="Translation.States">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="2754" />
    <option name="newTranslationDialogY" value="476" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Smaller pass index that waits for this pass." />
      <item value="Index of the pass that needs to be waited for." />
      <item value="This will be used to &quot;lock&quot; resource from being reused until the pipe has been synchronized." />
      <item value="We update the producer pass with the index of the smallest pass waiting for it. This will be used to &quot;lock&quot; resource from being reused until the pipe has been synchronized." />
      <item value="We want to know the highest pass index below the current pass that writes to the resource." />
      <item value="Producer will need a graphics fence that this pass will wait on." />
      <item value="Current pass needs to wait for pass index lastProducer" />
      <item value="Update latest pass waiting for the other pipe." />
      <item value="If the passes are on different pipes, we need synchronization" />
      <item value="Typedef for the in-engine RendererList API (to avoid conflicts with the experimental version)" />
      <item value="they can contain stale handles from a previous render graph execution that could still be considered valid if we only checked the index. In order to avoid using those, we incorporate the execution index in a 16 bits hash to make sure the handle is coming from the current execution. If not, it's considered invalid. We store this validity mask in the upper 16 bits of the index." />
      <item value="Note on handles validity. PassData classes used during render graph passes are pooled and because of that, when users don't fill them completely, they can contain stale handles from a previous render graph execution that could still be considered valid if we only checked the index. In order to avoid using those, we incorporate the execution index in a 16 bits hash to make sure the handle is coming from the current execution. If not, it's considered invalid. We store this validity mask in the upper 16 bits of the index." />
      <item value="expandable associative" />
      <item value="expandable" />
      <item value="The upper 16 bits and bits representing values &lt; 32 are masked out" />
      <item value="The latter is due to the fact that it will be included in what FIRST_BIT_LOW returns." />
      <item value="The latter is due to the fact that it will be" />
      <item value="USING STEREO MATRICES" />
      <item value="The light index can start at a non-multiple of 32, but the following iterations should always be multiples of 32. So we add 32 and mask out the lower bits." />
      <item value="Subtract 32 because it stores the index of the _next_ word to fetch, but we want the current. The upper 16 bits and bits representing values &lt; 32 are masked out. The latter is due to the fact that it will be included in what FIRST_BIT_LOW returns." />
      <item value="Calculate the lines making up the sides of the cone as seen from the camera. `l1` and `l2` form lines from the light position." />
      <item value="Intersect lines with y-plane and clip if needed." />
      <item value="Intersect lines with y-plane and clip if needed" />
      <item value="Mask out the beginning and end of the word" />
      <item value="Backward compatibility" />
      <item value="We don't use SSBO in D3D because we can't figure out without adding shader variants if platforms is D3D10." />
      <item value="We don't use SSBO in D3D because we can't figure out without adding shader variants if platforms is D3D10. GraphicsDeviceType deviceType = SystemInfo.graphicsDeviceType; return !Application.isMobilePlatform &amp;&amp; (deviceType == GraphicsDeviceType.Metal || deviceType == GraphicsDeviceType.Vulkan || deviceType == GraphicsDeviceType.PlayStation4 || deviceType == GraphicsDeviceType.PlayStation5 || deviceType == GraphicsDeviceType.XboxOne);" />
      <item value="When enabling this also enable USE_STRUCTURED_BUFFER_FOR_LIGHT_DATA in shader side in Input.hlsl" />
      <item value="There are some performance issues with StructuredBuffers in some platforms. We fallback to UBO in those cases." />
      <item value="TODO: For now disabling SSBO until figure out Vulkan binding issues. When enabling this also enable USE_STRUCTURED_BUFFER_FOR_LIGHT_DATA in shader side in Input.hlsl" />
      <item value="For now disabling SSBO until figure out Vulkan binding issues." />
      <item value="Setup Additional Light Constants" />
      <item value="Reinterpret" />
      <item value="Populate list of probes we need to remove to avoid modifying dictionary while iterating." />
      <item value="cannot do struct fixed arrays" />
      <item value="We split up the allocation struct because C cannot do struct fixed arrays :(" />
      <item value="o, d, u and v are expected to contain {x or y, z}. I.e. pass in x values to find tangents where x' = 0 Returns the two theta values as a float2. static float2 FindNearConicTangentTheta(float2 o, float2 d, float r, float2 u, float2 v) { var sqrt = math.sqrt(square(d.x) square(u.y) + square(d.x) square(v.y) - 2f d.x d.y u.x u.y - 2f d.x d.y v.x v.y + square(d.y) square(u.x) + square(d.y) square(v.x) - square(r) square(u.x) square(v.y) + 2f square(r) u.x u.y v.x v.y - square(r) square(u.y) square(v.x)); var denom = d.x v.y - d.y v.x - r u.x v.y + r u.y v.x; return 2 math.atan((-d.x u.y + d.y u.x + math.float2(1, -1) sqrt) denom); }" />
      <item value="Returns the two theta values as a float2." />
      <item value="o, d, u and v are expected to contain {x or y, z}. I.e. pass in x values to find tangents where x' = 0 Returns the two theta values as a float2." />
      <item value="Handle base circle clipping by intersecting it with the near-plane if needed." />
      <item value="Find Near Conic Tangent Theta" />
      <item value="The cross product will be the 0-vector if the light-direction and camera-to-light-position vectors are parallel. In that case, {1, 0, 0} is orthogonal to the light direction and we use that instead." />
      <item value="Get Cone Side Tangent Points" />
      <item value="The first horizon point expressed as factors of" />
      <item value="Find Y by putting polar into line equation and solving. Denormalize by dividing by U and V lengths." />
      <item value="polar" />
      <item value="Find Y by putting polar into line equation and solving" />
      <item value="Major and minor axis of the ellipse" />
      <item value="Find the polar line of the camera position in the normalized UV coordinate system." />
      <item value="Project the camera position into a 2D coordinate system with the circle at (0, 0) and the ellipse major and minor axes as the coordinate system axes. This allows us to use the standard form of the ellipse equation, greatly simplifying the calculations." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="231" />
        <entry key="ENGLISH" value="232" />
        <entry key="GERMAN" value="1" />
      </map>
    </option>
  </component>
</application>