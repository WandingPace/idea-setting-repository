<application>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1701411319107" />
  </component>
  <component name="Translation.Settings">
    <option name="primaryLanguage" value="CHINESE" />
  </component>
  <component name="Translation.States">
    <option name="newTranslationDialogWidth" value="596" />
    <option name="newTranslationDialogX" value="3216" />
    <option name="newTranslationDialogY" value="773" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="eplise" />
      <item value="magnitude" />
      <item value="Caching the plane normals allows the culling code to avoid calling property getters on the Plane instances" />
      <item value="Caches the absolute values of plane normals for re-use during frustum culling of multiple AABB instances" />
      <item value="radius" />
      <item value="We need to smoothly fade attenuation to light range. We start fading linearly at 80% of light range" />
      <item value="directional and punctual lights." />
      <item value="punctual lights" />
      <item value="punctual" />
      <item value="Add a command to enable the hardware scissor rectangle" />
      <item value="Unity flips projection matrix in non-OpenGL platforms and when rendering to a render texture. If URP is rendering to RT: - Source Depth is upside down. We need to copy depth by using a shader that has flipped matrix as well so we have same orientaiton for source and copy depth. - This also guarantess to be standard across if we are using a depth prepass. - When shaders (including shader graph) render objects that sample depth they adjust uv sign with _ProjectionParams.x. (https:docs.unity3d.comManualSL-PlatformDifferences.html) - All good. If URP is NOT rendering to RT neither rendering with OpenGL: - Source Depth is NOT fliped. We CANNOT flip when copying depth and don't flip when sampling. (ProjectionParams.x == 1)" />
      <item value="Trianlgelute" />
      <item value="lute" />
      <item value="Calculate Z bounds of cone and check if it's overlapping with the near plane. From https:www.iquilezles.orgwwwarticlesdiskbboxdiskbbox.htm" />
      <item value="homogenous space" />
      <item value="homogenous" />
      <item value="Smaller pass index that waits for this pass." />
      <item value="Index of the pass that needs to be waited for." />
      <item value="This will be used to &quot;lock&quot; resource from being reused until the pipe has been synchronized." />
      <item value="We update the producer pass with the index of the smallest pass waiting for it. This will be used to &quot;lock&quot; resource from being reused until the pipe has been synchronized." />
      <item value="We want to know the highest pass index below the current pass that writes to the resource." />
      <item value="Producer will need a graphics fence that this pass will wait on." />
      <item value="Current pass needs to wait for pass index lastProducer" />
      <item value="Update latest pass waiting for the other pipe." />
      <item value="If the passes are on different pipes, we need synchronization" />
      <item value="Typedef for the in-engine RendererList API (to avoid conflicts with the experimental version)" />
      <item value="they can contain stale handles from a previous render graph execution that could still be considered valid if we only checked the index. In order to avoid using those, we incorporate the execution index in a 16 bits hash to make sure the handle is coming from the current execution. If not, it's considered invalid. We store this validity mask in the upper 16 bits of the index." />
      <item value="Note on handles validity. PassData classes used during render graph passes are pooled and because of that, when users don't fill them completely, they can contain stale handles from a previous render graph execution that could still be considered valid if we only checked the index. In order to avoid using those, we incorporate the execution index in a 16 bits hash to make sure the handle is coming from the current execution. If not, it's considered invalid. We store this validity mask in the upper 16 bits of the index." />
      <item value="expandable associative" />
      <item value="expandable" />
      <item value="The upper 16 bits and bits representing values &lt; 32 are masked out" />
      <item value="The latter is due to the fact that it will be included in what FIRST_BIT_LOW returns." />
      <item value="The latter is due to the fact that it will be" />
      <item value="USING STEREO MATRICES" />
      <item value="The light index can start at a non-multiple of 32, but the following iterations should always be multiples of 32. So we add 32 and mask out the lower bits." />
      <item value="Subtract 32 because it stores the index of the _next_ word to fetch, but we want the current. The upper 16 bits and bits representing values &lt; 32 are masked out. The latter is due to the fact that it will be included in what FIRST_BIT_LOW returns." />
      <item value="Calculate the lines making up the sides of the cone as seen from the camera. `l1` and `l2` form lines from the light position." />
      <item value="Intersect lines with y-plane and clip if needed." />
      <item value="Intersect lines with y-plane and clip if needed" />
      <item value="Mask out the beginning and end of the word" />
      <item value="Backward compatibility" />
      <item value="We don't use SSBO in D3D because we can't figure out without adding shader variants if platforms is D3D10." />
      <item value="We don't use SSBO in D3D because we can't figure out without adding shader variants if platforms is D3D10. GraphicsDeviceType deviceType = SystemInfo.graphicsDeviceType; return !Application.isMobilePlatform &amp;&amp; (deviceType == GraphicsDeviceType.Metal || deviceType == GraphicsDeviceType.Vulkan || deviceType == GraphicsDeviceType.PlayStation4 || deviceType == GraphicsDeviceType.PlayStation5 || deviceType == GraphicsDeviceType.XboxOne);" />
      <item value="When enabling this also enable USE_STRUCTURED_BUFFER_FOR_LIGHT_DATA in shader side in Input.hlsl" />
      <item value="There are some performance issues with StructuredBuffers in some platforms. We fallback to UBO in those cases." />
      <item value="TODO: For now disabling SSBO until figure out Vulkan binding issues. When enabling this also enable USE_STRUCTURED_BUFFER_FOR_LIGHT_DATA in shader side in Input.hlsl" />
      <item value="For now disabling SSBO until figure out Vulkan binding issues." />
      <item value="Setup Additional Light Constants" />
      <item value="Reinterpret" />
      <item value="Populate list of probes we need to remove to avoid modifying dictionary while iterating." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="248" />
        <entry key="ENGLISH" value="248" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="1" />
      </map>
    </option>
  </component>
</application>