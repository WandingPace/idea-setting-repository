<application>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1696641794082" />
  </component>
  <component name="Translation.Settings">
    <option name="primaryLanguage" value="CHINESE" />
  </component>
  <component name="Translation.States">
    <option name="newTranslationDialogWidth" value="598" />
    <option name="newTranslationDialogX" value="2754" />
    <option name="newTranslationDialogY" value="476" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="The light index can start at a non-multiple of 32, but the following iterations should always be multiples of 32. So we add 32 and mask out the lower bits." />
      <item value="Subtract 32 because it stores the index of the _next_ word to fetch, but we want the current. The upper 16 bits and bits representing values &lt; 32 are masked out. The latter is due to the fact that it will be included in what FIRST_BIT_LOW returns." />
      <item value="Calculate the lines making up the sides of the cone as seen from the camera. `l1` and `l2` form lines from the light position." />
      <item value="Intersect lines with y-plane and clip if needed." />
      <item value="Intersect lines with y-plane and clip if needed" />
      <item value="Mask out the beginning and end of the word" />
      <item value="Backward compatibility" />
      <item value="We don't use SSBO in D3D because we can't figure out without adding shader variants if platforms is D3D10." />
      <item value="We don't use SSBO in D3D because we can't figure out without adding shader variants if platforms is D3D10. GraphicsDeviceType deviceType = SystemInfo.graphicsDeviceType; return !Application.isMobilePlatform &amp;&amp; (deviceType == GraphicsDeviceType.Metal || deviceType == GraphicsDeviceType.Vulkan || deviceType == GraphicsDeviceType.PlayStation4 || deviceType == GraphicsDeviceType.PlayStation5 || deviceType == GraphicsDeviceType.XboxOne);" />
      <item value="When enabling this also enable USE_STRUCTURED_BUFFER_FOR_LIGHT_DATA in shader side in Input.hlsl" />
      <item value="There are some performance issues with StructuredBuffers in some platforms. We fallback to UBO in those cases." />
      <item value="TODO: For now disabling SSBO until figure out Vulkan binding issues. When enabling this also enable USE_STRUCTURED_BUFFER_FOR_LIGHT_DATA in shader side in Input.hlsl" />
      <item value="For now disabling SSBO until figure out Vulkan binding issues." />
      <item value="Setup Additional Light Constants" />
      <item value="Reinterpret" />
      <item value="Populate list of probes we need to remove to avoid modifying dictionary while iterating." />
      <item value="cannot do struct fixed arrays" />
      <item value="We split up the allocation struct because C cannot do struct fixed arrays :(" />
      <item value="o, d, u and v are expected to contain {x or y, z}. I.e. pass in x values to find tangents where x' = 0 Returns the two theta values as a float2. static float2 FindNearConicTangentTheta(float2 o, float2 d, float r, float2 u, float2 v) { var sqrt = math.sqrt(square(d.x) square(u.y) + square(d.x) square(v.y) - 2f d.x d.y u.x u.y - 2f d.x d.y v.x v.y + square(d.y) square(u.x) + square(d.y) square(v.x) - square(r) square(u.x) square(v.y) + 2f square(r) u.x u.y v.x v.y - square(r) square(u.y) square(v.x)); var denom = d.x v.y - d.y v.x - r u.x v.y + r u.y v.x; return 2 math.atan((-d.x u.y + d.y u.x + math.float2(1, -1) sqrt) denom); }" />
      <item value="Returns the two theta values as a float2." />
      <item value="o, d, u and v are expected to contain {x or y, z}. I.e. pass in x values to find tangents where x' = 0 Returns the two theta values as a float2." />
      <item value="Handle base circle clipping by intersecting it with the near-plane if needed." />
      <item value="Find Near Conic Tangent Theta" />
      <item value="The cross product will be the 0-vector if the light-direction and camera-to-light-position vectors are parallel. In that case, {1, 0, 0} is orthogonal to the light direction and we use that instead." />
      <item value="Get Cone Side Tangent Points" />
      <item value="The first horizon point expressed as factors of" />
      <item value="Find Y by putting polar into line equation and solving. Denormalize by dividing by U and V lengths." />
      <item value="polar" />
      <item value="Find Y by putting polar into line equation and solving" />
      <item value="Major and minor axis of the ellipse" />
      <item value="Find the polar line of the camera position in the normalized UV coordinate system." />
      <item value="Project the camera position into a 2D coordinate system with the circle at (0, 0) and the ellipse major and minor axes as the coordinate system axes. This allows us to use the standard form of the ellipse equation, greatly simplifying the calculations." />
      <item value="Intersect Ellipse Line" />
      <item value="Calculates the horizon of a circle orthogonally projected to a plane as seen from the origin on the plane." />
      <item value="Calculate tile plane ranges for cone" />
      <item value="Calculate tile plane ranges for cone." />
      <item value="Calculate the lines making up the sides of the cone as seen from the camera. `l1` and `l2` form lines" />
      <item value="Find the X bounds of the near-plane cone intersection, i.e. where x' = 0" />
      <item value="Find the Y bounds of the near-plane cone intersection," />
      <item value="Conic" />
      <item value="Project cone base into the XZ plane, find the horizon points, and re-construct view space position of found points." />
      <item value="See comment for YZ plane for details" />
      <item value="Project cone base (a circle) into the YZ plane, find the horizon points, and re-construct view space position of found points. When projecting a circle to a plane, it becomes an ellipse where the major axis is parallel to the line of intersection of the projection plane and the circle plane. We can get this by taking the cross product of the two plane normals, as the line of intersection will have to be a vector in both planes, and thus orthogonal to both normals. If the two plane normals are parallel, the cross product would return 0. In that case, the circle will project to a line segment, so we pick a vector in the plane pointing in the direction we're interested in finding horizon points in." />
      <item value="the point is on the sphere, it must be `sphereRadius` from the sphere center, forming the hypotenuse. The other side is between the sphere and circle centers, which we've already calculated to be `distanceToPlane`." />
      <item value="Pythagoras" />
      <item value="Finds the two points of intersection of a 3D circle and the near plane." />
      <item value="thus orthogonal to both normals." />
      <item value="Transform horizon points to view space and use if not clipped." />
      <item value="They are signs that clipping is needed, so we fallback on the already calculated values in that case." />
      <item value="negative square roots." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="213" />
        <entry key="ENGLISH" value="214" />
        <entry key="GERMAN" value="1" />
      </map>
    </option>
  </component>
</application>